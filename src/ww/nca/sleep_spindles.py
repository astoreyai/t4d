"""
Sleep Spindle Generator for World Weaver.

Implements thalamocortical sleep spindles (11-16 Hz) for memory consolidation.

Biological basis:
- Generated by thalamic reticular nucleus (TRN)
- Occur during NREM stage 2 sleep
- Coupled to delta up-states (phase-locked)
- Gate hippocampal-cortical memory transfer
- Duration: 0.5-2 seconds per spindle burst

Hinton connection:
- Spindles = "gating signal" for memory consolidation
- Coordinate with SWR for replay timing
- Enable cortical plasticity windows

References:
- Steriade et al. (1993): Thalamocortical oscillations
- Diekelmann & Born (2010): Memory consolidation in sleep
- Latchoumane et al. (2017): Spindle-SWR coupling
"""

from collections import deque
from dataclasses import dataclass
from enum import Enum
from typing import Any

import numpy as np


class SpindleState(Enum):
    """Sleep spindle burst state."""
    INACTIVE = "inactive"       # No spindle activity
    WAXING = "waxing"          # Spindle amplitude increasing
    PLATEAU = "plateau"        # Spindle at peak amplitude
    WANING = "waning"          # Spindle amplitude decreasing


@dataclass
class SpindleConfig:
    """Configuration for sleep spindle generator.

    Parameters based on human EEG literature:
    - Frequency: 11-16 Hz (sigma band)
    - Duration: 0.5-2 seconds
    - Density: 2-5 spindles per minute of NREM2
    """

    # Frequency parameters
    freq_hz: float = 13.0             # Center frequency
    freq_range: tuple[float, float] = (11.0, 16.0)
    freq_variability: float = 0.5     # Hz variation within spindle

    # Amplitude parameters
    peak_amplitude: float = 0.5       # Maximum spindle amplitude
    baseline_amplitude: float = 0.02  # Background activity

    # Duration parameters (milliseconds)
    min_duration_ms: float = 500.0
    max_duration_ms: float = 2000.0
    wax_fraction: float = 0.25        # Fraction of duration for waxing
    wane_fraction: float = 0.25       # Fraction of duration for waning

    # Timing parameters
    refractory_period_ms: float = 3000.0  # Minimum time between spindles
    delta_coupling_strength: float = 0.8   # Coupling to delta up-states

    # Neuromodulator sensitivity
    gaba_sensitivity: float = 0.4     # GABAergic TRN involvement
    ach_sensitivity: float = -0.3     # ACh suppresses spindles (REM suppression)

    # Integration
    dt_ms: float = 1.0


@dataclass
class SpindleEvent:
    """Record of a single spindle burst."""
    start_time_ms: float
    end_time_ms: float
    peak_amplitude: float
    mean_frequency: float
    coupled_to_delta: bool

    @property
    def duration_ms(self) -> float:
        return self.end_time_ms - self.start_time_ms


class SleepSpindleGenerator:
    """
    Thalamocortical sleep spindle generator (11-16 Hz).

    Generates spindle bursts during NREM sleep that:
    1. Couple to delta oscillation up-states
    2. Gate hippocampal-cortical memory transfer
    3. Enable cortical plasticity windows

    Example:
        >>> config = SpindleConfig()
        >>> spindle_gen = SleepSpindleGenerator(config)
        >>> output = spindle_gen.step(
        ...     sleep_depth=0.7,
        ...     delta_up_state=True,
        ...     gaba_level=0.5
        ... )
        >>> print(output['spindle_active'], output['amplitude'])
    """

    def __init__(self, config: SpindleConfig | None = None):
        self.config = config or SpindleConfig()

        # Oscillator state
        self.phase = 0.0
        self.freq = self.config.freq_hz
        self.amplitude = self.config.baseline_amplitude

        # Spindle burst state
        self.state = SpindleState.INACTIVE
        self._burst_start_ms = 0.0
        self._burst_duration_ms = 0.0
        self._time_since_last_spindle_ms = float('inf')
        self._current_time_ms = 0.0

        # Event history
        self._spindle_events: deque[SpindleEvent] = deque(maxlen=100)
        self._output_history: deque[float] = deque(maxlen=2000)

        # Statistics
        self._total_spindles = 0
        self._delta_coupled_spindles = 0

    def step(
        self,
        sleep_depth: float,
        delta_up_state: bool,
        gaba_level: float = 0.5,
        ach_level: float = 0.3,
        dt_ms: float | None = None
    ) -> dict[str, Any]:
        """
        Advance spindle generator by one timestep.

        Args:
            sleep_depth: Sleep depth (0=awake, 1=deep NREM)
            delta_up_state: Whether in delta oscillation up-state
            gaba_level: GABA concentration (TRN activity)
            ach_level: Acetylcholine level (suppresses spindles)
            dt_ms: Timestep in milliseconds

        Returns:
            Dict with spindle output and state information
        """
        dt = dt_ms or self.config.dt_ms
        self._current_time_ms += dt

        # No spindles when awake or in REM (high ACh)
        if sleep_depth < 0.3 or ach_level > 0.6:
            self._deactivate_spindle()
            return self._make_output(0.0)

        # Update time since last spindle
        if self.state == SpindleState.INACTIVE:
            self._time_since_last_spindle_ms += dt

        # Check for spindle initiation
        if self._should_initiate_spindle(sleep_depth, delta_up_state, gaba_level, ach_level):
            self._initiate_spindle(delta_up_state)

        # Generate spindle output
        output = self._generate_spindle_output(dt)

        # Update spindle state
        self._update_spindle_state(dt)

        # Track history
        self._output_history.append(output)

        return self._make_output(output)

    def _should_initiate_spindle(
        self,
        sleep_depth: float,
        delta_up_state: bool,
        gaba_level: float,
        ach_level: float
    ) -> bool:
        """Determine if a new spindle should be initiated."""
        if self.state != SpindleState.INACTIVE:
            return False

        # Check refractory period
        if self._time_since_last_spindle_ms < self.config.refractory_period_ms:
            return False

        # Base probability increases with sleep depth
        base_prob = 0.001 * sleep_depth  # Per ms probability

        # Delta up-state coupling increases probability
        if delta_up_state:
            base_prob *= (1.0 + self.config.delta_coupling_strength)

        # GABA increases probability (TRN activation)
        gaba_mod = 1.0 + self.config.gaba_sensitivity * (gaba_level - 0.5)
        base_prob *= max(0.5, gaba_mod)

        # ACh suppresses spindles
        ach_mod = 1.0 + self.config.ach_sensitivity * (ach_level - 0.3)
        base_prob *= max(0.2, ach_mod)

        return np.random.random() < base_prob

    def _initiate_spindle(self, coupled_to_delta: bool) -> None:
        """Start a new spindle burst."""
        self.state = SpindleState.WAXING
        self._burst_start_ms = self._current_time_ms
        self._time_since_last_spindle_ms = 0.0

        # Randomize duration
        self._burst_duration_ms = np.random.uniform(
            self.config.min_duration_ms,
            self.config.max_duration_ms
        )

        # Randomize frequency within range
        self.freq = np.random.uniform(*self.config.freq_range)

        # Record coupling
        self._current_coupled = coupled_to_delta

        self._total_spindles += 1
        if coupled_to_delta:
            self._delta_coupled_spindles += 1

    def _generate_spindle_output(self, dt: float) -> float:
        """Generate spindle oscillation output."""
        if self.state == SpindleState.INACTIVE:
            # Low-amplitude background activity
            self.amplitude = self.config.baseline_amplitude
        else:
            # Calculate envelope
            elapsed = self._current_time_ms - self._burst_start_ms
            envelope = self._calculate_envelope(elapsed)
            self.amplitude = self.config.peak_amplitude * envelope

        # Add frequency jitter
        freq_jitter = np.random.uniform(
            -self.config.freq_variability,
            self.config.freq_variability
        )
        current_freq = np.clip(
            self.freq + freq_jitter,
            *self.config.freq_range
        )

        # Phase advance
        dt_sec = dt / 1000.0
        phase_increment = 2 * np.pi * current_freq * dt_sec
        self.phase = (self.phase + phase_increment) % (2 * np.pi)

        # Output
        return self.amplitude * np.sin(self.phase)

    def _calculate_envelope(self, elapsed_ms: float) -> float:
        """Calculate spindle amplitude envelope (waxing-plateau-waning)."""
        duration = self._burst_duration_ms
        wax_end = duration * self.config.wax_fraction
        wane_start = duration * (1 - self.config.wane_fraction)

        if elapsed_ms < wax_end:
            # Waxing: smooth increase
            t = elapsed_ms / wax_end
            return 0.5 * (1 - np.cos(np.pi * t))
        elif elapsed_ms < wane_start:
            # Plateau: full amplitude
            return 1.0
        elif elapsed_ms < duration:
            # Waning: smooth decrease
            t = (elapsed_ms - wane_start) / (duration - wane_start)
            return 0.5 * (1 + np.cos(np.pi * t))
        else:
            return 0.0

    def _update_spindle_state(self, dt: float) -> None:
        """Update spindle burst state machine."""
        if self.state == SpindleState.INACTIVE:
            return

        elapsed = self._current_time_ms - self._burst_start_ms
        duration = self._burst_duration_ms
        wax_end = duration * self.config.wax_fraction
        wane_start = duration * (1 - self.config.wane_fraction)

        if elapsed < wax_end:
            self.state = SpindleState.WAXING
        elif elapsed < wane_start:
            self.state = SpindleState.PLATEAU
        elif elapsed < duration:
            self.state = SpindleState.WANING
        else:
            self._finish_spindle()

    def _finish_spindle(self) -> None:
        """Complete a spindle burst and record event."""
        event = SpindleEvent(
            start_time_ms=self._burst_start_ms,
            end_time_ms=self._current_time_ms,
            peak_amplitude=self.config.peak_amplitude,
            mean_frequency=self.freq,
            coupled_to_delta=self._current_coupled
        )
        self._spindle_events.append(event)
        self._deactivate_spindle()

    def _deactivate_spindle(self) -> None:
        """Deactivate spindle generator."""
        self.state = SpindleState.INACTIVE
        self.amplitude = self.config.baseline_amplitude

    def _make_output(self, value: float) -> dict[str, Any]:
        """Create output dictionary."""
        return {
            "spindle_output": value,
            "amplitude": self.amplitude,
            "frequency": self.freq,
            "phase": self.phase,
            "state": self.state.value,
            "spindle_active": self.state != SpindleState.INACTIVE,
            "consolidation_gate": self.get_consolidation_gate(),
        }

    def get_consolidation_gate(self) -> float:
        """
        Get memory consolidation gating signal.

        Spindles gate hippocampal-cortical transfer:
        - 1.0 during plateau phase (peak consolidation)
        - 0.5 during waxing/waning
        - 0.0 when inactive
        """
        if self.state == SpindleState.PLATEAU:
            return 1.0
        elif self.state in (SpindleState.WAXING, SpindleState.WANING):
            return 0.5
        else:
            return 0.0

    def get_plasticity_window(self) -> bool:
        """
        Check if in plasticity window.

        Spindles enable cortical plasticity for memory consolidation.
        """
        return self.state != SpindleState.INACTIVE

    def get_recent_spindles(self, window_ms: float = 60000.0) -> list[SpindleEvent]:
        """Get spindle events within time window."""
        cutoff = self._current_time_ms - window_ms
        return [e for e in self._spindle_events if e.start_time_ms > cutoff]

    def get_spindle_density(self, window_ms: float = 60000.0) -> float:
        """
        Calculate spindle density (spindles per minute).

        Normal range: 2-5 spindles/min during NREM2.
        """
        recent = self.get_recent_spindles(window_ms)
        minutes = window_ms / 60000.0
        return len(recent) / minutes if minutes > 0 else 0.0

    def get_delta_coupling_ratio(self) -> float:
        """
        Get fraction of spindles coupled to delta up-states.

        Higher coupling = better memory consolidation.
        """
        if self._total_spindles == 0:
            return 0.0
        return self._delta_coupled_spindles / self._total_spindles

    def compute_spindle_power(self) -> float:
        """Compute spindle band power from recent history."""
        if len(self._output_history) < 100:
            return 0.0
        arr = np.array(self._output_history)
        return float(np.var(arr))

    def reset(self) -> None:
        """Reset spindle generator to initial state."""
        self.phase = 0.0
        self.freq = self.config.freq_hz
        self.amplitude = self.config.baseline_amplitude
        self.state = SpindleState.INACTIVE
        self._burst_start_ms = 0.0
        self._burst_duration_ms = 0.0
        self._time_since_last_spindle_ms = float('inf')
        self._current_time_ms = 0.0
        self._spindle_events.clear()
        self._output_history.clear()
        self._total_spindles = 0
        self._delta_coupled_spindles = 0

    def get_stats(self) -> dict[str, Any]:
        """Get comprehensive spindle statistics."""
        return {
            "total_spindles": self._total_spindles,
            "delta_coupled_spindles": self._delta_coupled_spindles,
            "coupling_ratio": self.get_delta_coupling_ratio(),
            "spindle_density": self.get_spindle_density(),
            "current_state": self.state.value,
            "current_frequency": self.freq,
            "current_amplitude": self.amplitude,
            "spindle_power": self.compute_spindle_power(),
        }

    def validate_spindles(self) -> dict[str, Any]:
        """Validate spindle properties against biological criteria."""
        stats = self.get_stats()

        results = {
            # Frequency should be in sigma band (11-16 Hz)
            "freq_valid": 11.0 <= stats["current_frequency"] <= 16.0,

            # Spindle density should be reasonable (0-10 per minute)
            "density_valid": 0.0 <= stats["spindle_density"] <= 10.0,

            # Coupling ratio should show some delta coupling
            "coupling_present": stats["coupling_ratio"] > 0.3 if self._total_spindles > 5 else True,
        }

        results["all_pass"] = all(results.values())
        return results


class SpindleDeltaCoupler:
    """
    Couples sleep spindles to delta oscillation up-states.

    Implements the temporal coordination critical for memory consolidation:
    - Spindles preferentially occur during delta up-states
    - This coupling maximizes hippocampal-cortical transfer
    - Disrupting coupling impairs memory consolidation
    """

    def __init__(
        self,
        spindle_gen: SleepSpindleGenerator,
        coupling_window_ms: float = 200.0
    ):
        self.spindle_gen = spindle_gen
        self.coupling_window_ms = coupling_window_ms

        # Track up-state timing
        self._last_up_state_start_ms = 0.0
        self._in_coupling_window = False

    def update(
        self,
        current_time_ms: float,
        delta_up_state: bool,
        prev_delta_up_state: bool
    ) -> bool:
        """
        Update coupling state based on delta oscillation.

        Args:
            current_time_ms: Current simulation time
            delta_up_state: Whether currently in up-state
            prev_delta_up_state: Previous up-state

        Returns:
            Whether in optimal coupling window for spindle
        """
        # Detect up-state onset
        if delta_up_state and not prev_delta_up_state:
            self._last_up_state_start_ms = current_time_ms

        # Check coupling window (spindles optimally start ~100-200ms into up-state)
        if delta_up_state:
            elapsed = current_time_ms - self._last_up_state_start_ms
            self._in_coupling_window = 50.0 <= elapsed <= self.coupling_window_ms
        else:
            self._in_coupling_window = False

        return self._in_coupling_window

    def get_coupling_quality(self) -> float:
        """
        Get current coupling quality score.

        Higher = better timing for spindle initiation.
        """
        if not self._in_coupling_window:
            return 0.0

        # Peak coupling in middle of window
        elapsed = self.spindle_gen._current_time_ms - self._last_up_state_start_ms
        optimal = self.coupling_window_ms / 2
        distance = abs(elapsed - optimal)
        quality = 1.0 - (distance / optimal)
        return max(0.0, quality)


# =============================================================================
# C6: Slow Oscillation (0.5-1 Hz) for Delta Up/Down State Gating
# =============================================================================


@dataclass
class SlowOscillationConfig:
    """Configuration for slow oscillation (0.5-1 Hz delta)."""

    frequency_hz: float = 0.75  # Slow oscillation frequency (0.5-1 Hz)
    up_state_fraction: float = 0.6  # Fraction of cycle in up-state
    enable_spindle_gating: bool = True  # Gate spindles to up-state only


class SlowOscillation:
    """
    C6: Slow oscillation (0.5-1 Hz) with up/down state cycling.

    Gates spindle generation to occur only during up-states, matching
    biological observations that spindles are nested in delta up-states.

    Biological basis:
    - Slow oscillations (0.5-1 Hz) are fundamental cortical rhythms during NREM
    - Spindles occur during up-states (depolarized membrane potential)
    - Down-states are hyperpolarized quiescent periods
    - Up-states drive CSF flow in glymphatic system (Fultz et al. 2019)

    Usage:
        slow_osc = SlowOscillation()
        slow_osc.step(dt_ms=1.0)
        if slow_osc.is_up_state:
            # Generate spindles
    """

    def __init__(self, config: SlowOscillationConfig | None = None):
        """
        Initialize slow oscillation.

        Args:
            config: Slow oscillation configuration
        """
        self.config = config or SlowOscillationConfig()

        self.phase: float = 0.0  # Current phase [0, 2π]
        self.frequency: float = self.config.frequency_hz
        self._current_time_ms: float = 0.0

    @property
    def is_up_state(self) -> bool:
        """
        Check if currently in up-state.

        Up-state occurs when phase is in [0, up_state_fraction * 2π].

        Returns:
            True if in up-state
        """
        normalized_phase = self.phase / (2 * np.pi)  # [0, 1]
        return normalized_phase < self.config.up_state_fraction

    @property
    def up_state_strength(self) -> float:
        """
        Get up-state strength (0=down-state, 1=peak up-state).

        Returns:
            Up-state strength [0, 1]
        """
        if not self.is_up_state:
            return 0.0

        # Sinusoidal modulation within up-state
        normalized_phase = self.phase / (2 * np.pi)
        up_phase = normalized_phase / self.config.up_state_fraction
        return float(0.5 * (1.0 + np.cos(2 * np.pi * up_phase - np.pi)))

    def step(self, dt_ms: float) -> dict:
        """
        Advance slow oscillation.

        Args:
            dt_ms: Time step in milliseconds

        Returns:
            Dict with oscillation state
        """
        self._current_time_ms += dt_ms

        # Phase advance
        dt_sec = dt_ms / 1000.0
        phase_increment = 2 * np.pi * self.frequency * dt_sec
        self.phase = (self.phase + phase_increment) % (2 * np.pi)

        return {
            "phase": self.phase,
            "is_up_state": self.is_up_state,
            "up_state_strength": self.up_state_strength,
            "frequency": self.frequency,
        }

    def reset(self) -> None:
        """Reset oscillation."""
        self.phase = 0.0
        self._current_time_ms = 0.0
